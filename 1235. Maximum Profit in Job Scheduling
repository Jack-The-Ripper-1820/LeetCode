class Solution:
    """
    in every turn we either select the time range (if its valid) or we skip that time range
    """
    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:
        n = len(profit)
        times = [(startTime[i], endTime[i], profit[i]) for i in range(n)]
        times.sort(key = lambda x : x[0])
        
        @lru_cache(None)
        def helper(ind):
            if(ind >= n):
                return 0
            
            nextInd = find(ind)
            dontSkip = times[ind][2] + (0 if nextInd == -1 else helper(nextInd))
            skip = helper(ind + 1)
            
            return max(skip, dontSkip)
        
        def find(ind):
            for i in range(ind + 1, n):
                if(times[i][0] >= times[ind][1]):
                    return i
            return -1
        
        return helper(0)
        

class Solution {
public:
    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {
        int n = profit.size();
        vector<vector<int>> esp(n);
        
        for(int i = 0; i < n; i++) esp[i] = {endTime[i], startTime[i], profit[i]};
        
        map<int, int> dp = {{0, 0}};
        sort(esp.begin(), esp.end());
        
        for(auto &x : esp) {
            int cur = prev(dp.upper_bound(x[1]))->second + x[2];
            
            if(cur > dp.rbegin()->second)
                dp[x[0]] = cur;
        }
        
        return dp.rbegin()->second;
    }
};
