class Solution {
    int dp[501];
    
    int helper(vector<int> const& arr, int const& k, int ind) {
        if(ind >= arr.size())
            return 0;
        
        if(dp[ind] != -1)
            return dp[ind];
        
        int curmax = 0, ans = 0;
        
        for(int i = ind, len = 1; i < ind + k and i < arr.size(); i++, len++) {
            curmax = max(curmax, arr[i]);
            ans = max(ans, helper(arr, k, i + 1) + len * curmax);
        }
        
        return dp[ind] = ans;
    }
public:
    int maxSumAfterPartitioning(vector<int>& arr, int k) {
        memset(dp, -1, sizeof(dp));
        return helper(arr, k, 0);
    }
};

class Solution:
    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:
        dp = [-1] * len(arr)
        
        def helper(arr, i, k, dp):
            if(i >= len(arr)):
                return 0
            
            if(dp[i] != -1):
                return dp[i]
            
            m = -1
            ans = 0
            for j in range(i, i + k):
                
                if(j >= len(arr)):
                    break
                
                m = max(arr[j], m)
                cutNow = m * (j - i + 1)
                cutLater = helper(arr, j + 1, k, dp)
                ans = max(cutNow + cutLater, ans)
            
            dp[i] = ans
            return ans
                
            
        return helper(arr, 0, k, dp)
